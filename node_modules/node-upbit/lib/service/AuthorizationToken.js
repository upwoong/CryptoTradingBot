"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const querystring_1 = __importDefault(require("querystring"));
const uuid_1 = require("uuid");
class AuthorizationToken {
    constructor(UBIT_ACCESS_KEY, UBIT_SECRET_KEY) {
        this.UBIT_ACCESS_KEY = UBIT_ACCESS_KEY || "";
        this.UBIT_SECRET_KEY = UBIT_SECRET_KEY || "";
    }
    Validation() {
        if (this.UBIT_ACCESS_KEY === "" || this.UBIT_SECRET_KEY === "") {
            console.log("업비트 ACCESS_KEY 또는 SECRET_KEY를 확인하십시오.");
            return false;
        }
        return true;
    }
    getAuthorizationTokenNoParam() {
        if (!this.Validation()) {
            throw new Error("업비트 ACCESS_KEY 또는 SECRET_KEY를 확인하십시오.");
        }
        const payload = {
            access_key: this.UBIT_ACCESS_KEY,
            nonce: uuid_1.v4(),
        };
        const jwtToken = jsonwebtoken_1.default.sign(payload, this.UBIT_SECRET_KEY);
        return `Bearer ${jwtToken}`;
    }
    getAuthorizationToken(params) {
        if (!this.Validation()) {
            throw new Error("업비트 ACCESS_KEY 또는 SECRET_KEY를 확인하십시오.");
        }
        const query = querystring_1.default.encode(params);
        const hash = crypto_1.default.createHash("sha512");
        const queryHash = hash.update(query, "utf-8").digest("hex");
        const payload = {
            access_key: this.UBIT_ACCESS_KEY,
            nonce: uuid_1.v4(),
            query_hash: queryHash,
            query_hash_alg: "SHA512",
        };
        const jwtToken = jsonwebtoken_1.default.sign(payload, this.UBIT_SECRET_KEY);
        return { authorizationToken: `Bearer ${jwtToken}`, query };
    }
}
exports.default = AuthorizationToken;
//# sourceMappingURL=AuthorizationToken.js.map