"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const QuoationService_1 = __importDefault(require("./QuoationService"));
class UtilsService extends QuoationService_1.default {
    constructor() {
        super();
    }
    getOhlcav(type, market, count, to) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let arrayCandleData;
                switch (type) {
                    case "day":
                        arrayCandleData = yield this.getDayCandles({
                            marketCoin: market,
                            count: count,
                            to,
                        });
                        break;
                    case "1":
                    case "3":
                    case "5":
                    case "10":
                    case "15":
                    case "30":
                    case "60":
                    case "240":
                        arrayCandleData = yield this.getMinutesCandles({
                            minutes: type,
                            marketCoin: market,
                            count: count,
                            to,
                        });
                        break;
                }
                const ohlcv = arrayCandleData.map((item) => {
                    return {
                        market: item.market,
                        time: item.candle_date_time_kst,
                        open: item.opening_price,
                        high: item.high_price,
                        low: item.low_price,
                        close: item.trade_price,
                        accPrice: item.candle_acc_trade_price,
                        volume: item.candle_acc_trade_volume,
                    };
                });
                return ohlcv;
            }
            catch (err) {
                throw err;
            }
        });
    }
    getOhlcvPlusOne(type, market, count, to) {
        return __awaiter(this, void 0, void 0, function* () {
            count = count + 8 + 1;
            try {
                const ohlcv = yield this.getOhlcav(type, market, count, to);
                return ohlcv;
            }
            catch (err) {
                throw err;
            }
        });
    }
    getPrevMaAvg(df, maCount) {
        for (let i = df.length - 1; i >= 0; i--) {
            if (i >= maCount - 1) {
                let maSum = 0;
                for (let j = i; j >= i - (maCount - 1); j--) {
                    maSum += df[j].close || 0;
                }
                df[i].maAvg = maSum / maCount;
            }
        }
        return df;
    }
    getBollingerBand(df, maCount) {
        for (let i = df.length - 1; i >= 0; i--) {
            if (i >= maCount - 1) {
                let deviation = [];
                const maAvg = df[i].maAvg || 0;
                for (let j = i; j >= i - (maCount - 1); j--) {
                    deviation.push(df[j].close - maAvg);
                }
                const sumDeviation = deviation.reduce((acc, cur) => {
                    acc += cur * cur;
                    return acc;
                }, 0);
                const sqrt = Math.sqrt(sumDeviation / maCount);
                df[i].bollingerHigh = maAvg + sqrt * 2;
                df[i].bollingerLow = maAvg - sqrt * 2;
            }
        }
        return df;
    }
    getRsi(df, maCount) {
        for (let i = df.length - 1; i > 0; i--) {
            df[i].rs = df[i].close - df[i - 1].close || 0;
            df[i].rsiU = (df[i].rs || 0) > 0 ? df[i].rs : 0;
            df[i].rsiD = ((df[i].rs || 0) < 0 ? df[i].rs || 0 : 0) * -1;
        }
        let maSumPlus = 0;
        let maSumMinus = 0;
        for (let j = df.length - maCount; j < df.length; j++) {
            if (j === df.length - maCount) {
                for (let k = j; k > j - maCount; k--) {
                    maSumPlus += df[k].rsiU || 0;
                    maSumMinus += df[k].rsiD || 0;
                }
                df[j].rsiAU = maSumPlus / maCount;
                df[j].rsiDU = maSumMinus / maCount;
            }
            else {
                df[j].rsiAU =
                    ((df[j - 1].rsiAU || 0) * (maCount - 1) + (df[j].rsiU || 0)) /
                        maCount;
                df[j].rsiDU =
                    ((df[j - 1].rsiDU || 0) * (maCount - 1) + (df[j].rsiD || 0)) /
                        maCount;
            }
            df[j].rsi =
                ((df[j].rsiAU || 0) / ((df[j].rsiAU || 0) + (df[j].rsiDU || 0))) * 100;
        }
        return df;
    }
    getCmbr(type, market, count, to) {
        return __awaiter(this, void 0, void 0, function* () {
            let df = yield this.getOhlcvPlusOne(type, market, count, to);
            df = this.getPrevMaAvg(df, count);
            df = this.getBollingerBand(df, count);
            df = this.getRsi(df, 14);
            const lastIndex = df.length - 1;
            return {
                market: df[lastIndex].market,
                close: this.getFixed(df[lastIndex].close, 3),
                maAvg: this.getFixed(df[lastIndex].maAvg, 3),
                bollingerHigh: this.getFixed(df[lastIndex].bollingerHigh, 3),
                bollingerLow: this.getFixed(df[lastIndex].bollingerLow, 3),
                rsi: this.getFixed(df[lastIndex].rsi, 3),
            };
        });
    }
    getFixed(num, digits) {
        if (!Number.isInteger(num)) {
            return parseFloat(num.toFixed(digits));
        }
        return num;
    }
}
exports.default = UtilsService;
//# sourceMappingURL=UtilsService.js.map